// ==================== ðŸ†• SIMPLIFIED CONTEXT SLOT MANAGEMENT FUNCTIONS ====================

// ðŸ†• Get user's context addon slots and usage - SIMPLIFIED: Direct field access
const getContextAddonUsage = async (userId) => {
    try {
        const result = await pool.query(`
            SELECT 
                plan_context_slots,
                extra_context_slots,
                total_context_slots,
                contexts_count,
                plan_code
            FROM users 
            WHERE id = $1
        `, [userId]);
        
        if (result.rows.length === 0) {
            throw new Error('User not found');
        }
        
        const user = result.rows[0];
        
        return {
            success: true,
            data: {
                used: user.contexts_count || 0,
                baseLimit: user.plan_context_slots || 1,
                addonSlots: user.extra_context_slots || 0,
                totalLimit: user.total_context_slots || 1,
                planCode: user.plan_code
            }
        };
        
    } catch (error) {
        console.error('Error getting context addon usage:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// ðŸ†• Create context addon subscription - SIMPLIFIED: Direct field increment
const createContextAddon = async (userId, chargebeeSubscriptionId, addonDetails = {}) => {
    try {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');
            
            // Create addon record
            const addonResult = await client.query(`
                INSERT INTO user_context_addons (
                    user_id,
                    chargebee_subscription_id,
                    addon_quantity,
                    monthly_price,
                    billing_period_start,
                    billing_period_end,
                    next_billing_date,
                    status,
                    chargebee_status
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING *
            `, [
                userId,
                chargebeeSubscriptionId,
                addonDetails.quantity || 1,
                addonDetails.price || 3.99,
                addonDetails.periodStart || new Date(),
                addonDetails.periodEnd || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                addonDetails.nextBillingDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                'active',
                addonDetails.chargebeeStatus || 'active'
            ]);
            
            // ðŸ†• SIMPLIFIED: Increment extra_context_slots directly
            await client.query(`
                UPDATE users 
                SET extra_context_slots = extra_context_slots + $1,
                    total_context_slots = plan_context_slots + extra_context_slots + $1,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $2
            `, [addonDetails.quantity || 1, userId]);
            
            await client.query('COMMIT');
            
            console.log(`[CONTEXT_ADDON] Created addon subscription for user ${userId}: ${chargebeeSubscriptionId}`);
            
            return {
                success: true,
                data: addonResult.rows[0]
            };
            
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    } catch (error) {
        console.error('Error creating context addon:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// ðŸ†• Get user's active context addons
const getUserContextAddons = async (userId) => {
    try {
        const result = await pool.query(`
            SELECT 
                id,
                chargebee_subscription_id,
                addon_quantity,
                monthly_price,
                next_billing_date,
                status,
                created_at
            FROM user_context_addons 
            WHERE user_id = $1 AND status = 'active'
            ORDER BY created_at DESC
        `, [userId]);
        
        return {
            success: true,
            data: result.rows
        };
    } catch (error) {
        console.error('Error getting user context addons:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// ðŸ†• Update user context slots when plan changes (like credit functions)
const updateUserContextSlots = async (userId, newPlanCode) => {
    try {
        // Plan to context slots mapping
        const planContextSlots = {
            'free': 1,
            'silver-monthly': 3,
            'gold-monthly': 6,
            'platinum-monthly': 10,
            'silver-payasyougo': 1,
            'gold-payasyougo': 1,
            'platinum-payasyougo': 1
        };
        
        const newBaseSlots = planContextSlots[newPlanCode] || 1;
        
        const result = await pool.query(`
            UPDATE users 
            SET plan_context_slots = $1,
                total_context_slots = $1 + COALESCE(extra_context_slots, 0),
                updated_at = CURRENT_TIMESTAMP
            WHERE id = $2
            RETURNING plan_context_slots, extra_context_slots, total_context_slots
        `, [newBaseSlots, userId]);
        
        if (result.rows.length === 0) {
            throw new Error('User not found');
        }
        
        const slots = result.rows[0];
        
        return {
            success: true,
            baseSlots: Number(slots.plan_context_slots),
            extraSlots: Number(slots.extra_context_slots),
            totalSlots: Number(slots.total_context_slots)
        };
    } catch (error) {
        console.error('Error updating user context slots:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// ðŸ†• Remove context addon (decrement slots)
const removeContextAddon = async (userId, addonId) => {
    try {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');
            
            // Get addon details
            const addonResult = await client.query(`
                SELECT addon_quantity FROM user_context_addons 
                WHERE id = $1 AND user_id = $2
            `, [addonId, userId]);
            
            if (addonResult.rows.length === 0) {
                throw new Error('Addon not found');
            }
            
            const addonQuantity = addonResult.rows[0].addon_quantity || 1;
            
            // Cancel addon
            await client.query(`
                UPDATE user_context_addons 
                SET status = 'cancelled', updated_at = CURRENT_TIMESTAMP
                WHERE id = $1
            `, [addonId]);
            
            // ðŸ†• SIMPLIFIED: Decrement extra_context_slots directly
            await client.query(`
                UPDATE users 
                SET extra_context_slots = GREATEST(0, extra_context_slots - $1),
                    total_context_slots = plan_context_slots + GREATEST(0, extra_context_slots - $1),
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $2
            `, [addonQuantity, userId]);
            
            await client.query('COMMIT');
            
            return {
                success: true,
                removedSlots: addonQuantity
            };
            
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    } catch (error) {
        console.error('Error removing context addon:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// ==================== PENDING REGISTRATIONS FUNCTIONS ====================

// âœ… NEW: Store pending registration before payment
const storePendingRegistration = async (userId, linkedinUrl, packageType) => {
    try {
        // Remove any existing pending registrations for this user
        await pool.query(
            'DELETE FROM pending_registrations WHERE user_id = $1',
            [userId]
        );
        
        // Store new pending registration
        const result = await pool.query(`
            INSERT INTO pending_registrations (
                user_id, linkedin_url, package_type, terms_accepted
            ) VALUES ($1, $2, $3, $4) 
            RETURNING *
        `, [userId, linkedinUrl, packageType, true]);
        
        console.log(`[PENDING_REG] Stored pending registration for user ${userId}: ${packageType}`);
        
        return {
            success: true,
            data: result.rows[0]
        };
    } catch (error) {
        console.error('Error storing pending registration:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// âœ… NEW: Get pending registration for user
const getPendingRegistration = async (userId) => {
    try {
        const result = await pool.query(`
            SELECT * FROM pending_registrations 
            WHERE user_id = $1 AND completed_at IS NULL AND expired_at > CURRENT_TIMESTAMP
            ORDER BY created_at DESC
            LIMIT 1
        `, [userId]);
        
        if (result.rows.length === 0) {
            return {
                success: false,
                error: 'No pending registration found'
            };
        }
        
        return {
            success: true,
            data: result.rows[0]
        };
    } catch (error) {
        console.error('Error getting pending registration:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// âœ… NEW: Complete pending registration (called by webhook)
const completePendingRegistration = async (userId) => {
    try {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');
            
            // Get pending registration
            const pendingResult = await client.query(`
                SELECT * FROM pending_registrations 
                WHERE user_id = $1 AND completed_at IS NULL AND expired_at > CURRENT_TIMESTAMP
                ORDER BY created_at DESC
                LIMIT 1
            `, [userId]);
            
            if (pendingResult.rows.length === 0) {
                await client.query('ROLLBACK');
                return {
                    success: false,
                    error: 'No pending registration found'
                };
            }
            
            const pendingReg = pendingResult.rows[0];
            
            // Update user with LinkedIn URL and mark registration complete
            await client.query(`
                UPDATE users 
                SET linkedin_url = $1, 
                    registration_completed = true,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = $2
            `, [pendingReg.linkedin_url, userId]);
            
            // Mark pending registration as completed
            await client.query(`
                UPDATE pending_registrations 
                SET completed_at = CURRENT_TIMESTAMP
                WHERE id = $1
            `, [pendingReg.id]);
            
            await client.query('COMMIT');
            
            console.log(`[PENDING_REG] Completed registration for user ${userId} with LinkedIn URL: ${pendingReg.linkedin_url}`);
            
            return {
                success: true,
                data: {
                    linkedinUrl: pendingReg.linkedin_url,
                    packageType: pendingReg.package_type,
                    registrationCompleted: true
                }
            };
            
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    } catch (error) {
        console.error('Error completing pending registration:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// ==================== DATA PROCESSING HELPER FUNCTIONS ====================

// JSON validation and sanitization
const sanitizeForJSON = (data) => {
    if (data === null || data === undefined) {
        return null;
    }
    
    if (typeof data === 'string') {
        try {
            const parsed = JSON.parse(data);
            return parsed;
        } catch (e) {
            return data;
        }
    }
    
    if (Array.isArray(data)) {
        return data.map(item => sanitizeForJSON(item)).filter(item => item !== null);
    }
    
    if (typeof data === 'object') {
        const sanitized = {};
        for (const [key, value] of Object.entries(data)) {
            const sanitizedValue = sanitizeForJSON(value);
            if (sanitizedValue !== null) {
                sanitized[key] = sanitizedValue;
            }
        }
        return sanitized;
    }
    
    return data;
};

// Ensure arrays are properly formatted for PostgreSQL JSONB
const ensureValidJSONArray = (data) => {
    try {
        if (!data) {
            return [];
        }
        
        if (Array.isArray(data)) {
            const sanitized = data.map(item => sanitizeForJSON(item)).filter(item => item !== null);
            const testString = JSON.stringify(sanitized);
            JSON.parse(testString);
            return sanitized;
        }
        
        if (typeof data === 'string') {
            try {
                const parsed = JSON.parse(data);
                if (Array.isArray(parsed)) {
                    return ensureValidJSONArray(parsed);
                }
                return [parsed];
            } catch (e) {
                return [];
            }
        }
        
        if (typeof data === 'object') {
            return [sanitizeForJSON(data)];
        }
        
        return [];
    } catch (error) {
        console.error('Error ensuring valid JSON array:', error);
        return [];
    }
};

// Helper function to parse LinkedIn numbers
const parseLinkedInNumber = (str) => {
    if (!str) return null;
    if (typeof str === 'number') return str;
    
    try {
        const cleanStr = str.toString().toLowerCase().trim();
        
        if (cleanStr.includes('m')) {
            const num = parseFloat(cleanStr.match(/[\d.]+/)?.[0]);
            return num ? Math.round(num * 1000000) : null;
        }
        if (cleanStr.includes('k')) {
            const num = parseFloat(cleanStr.match(/[\d.]+/)?.[0]);
            return num ? Math.round(num * 1000) : null;
        }
        
        const numbers = cleanStr.match(/[\d,]+/);
        if (numbers) {
            const cleanNumber = numbers[0].replace(/,/g, '');
            return parseInt(cleanNumber, 10) || null;
        }
        return null;
    } catch (error) {
        console.error('Error parsing LinkedIn number:', str, error);
        return null;
    }
};

// USER PROFILE ONLY: Process Gemini data (keeps working)
const processGeminiData = (geminiResponse, cleanProfileUrl) => {
    try {
        const aiData = geminiResponse.data;
        const profile = aiData.profile || {};
        const engagement = aiData.engagement || {};
        
        const processedData = {
            linkedinUrl: cleanProfileUrl,
            url: cleanProfileUrl,
            
            // Basic Info
            fullName: profile.name || '',
            firstName: profile.firstName || (profile.name ? profile.name.split(' ')[0] : ''),
            lastName: profile.lastName || (profile.name ? profile.name.split(' ').slice(1).join(' ') : ''),
            headline: profile.headline || '',
            currentJobTitle: profile.currentRole || '',
            about: profile.about || '',
            location: profile.location || '',
            
            // Company Info
            currentCompany: profile.currentCompany || '',
            currentCompanyName: profile.currentCompany || '',
            
            // Metrics
            connectionsCount: parseLinkedInNumber(profile.connectionsCount),
            followersCount: parseLinkedInNumber(profile.followersCount),
            mutualConnectionsCount: parseLinkedInNumber(profile.mutualConnections) || 0,
            
            // Enhanced engagement fields
            totalLikes: parseLinkedInNumber(engagement.totalLikes) || 0,
            totalComments: parseLinkedInNumber(engagement.totalComments) || 0,
            totalShares: parseLinkedInNumber(engagement.totalShares) || 0,
            averageLikes: parseFloat(engagement.averageLikes) || 0,
            
            // Complex data arrays
            experience: ensureValidJSONArray(aiData.experience || []),
            education: ensureValidJSONArray(aiData.education || []),
            skills: ensureValidJSONArray(aiData.skills || []),
            certifications: ensureValidJSONArray(aiData.certifications || []),
            awards: ensureValidJSONArray(aiData.awards || []),
            activity: ensureValidJSONArray(aiData.activity || []),
            volunteerExperience: ensureValidJSONArray(aiData.volunteer || []),
            followingCompanies: ensureValidJSONArray(aiData.followingCompanies || []),
            followingPeople: ensureValidJSONArray(aiData.followingPeople || []),
            followingHashtags: ensureValidJSONArray(aiData.followingHashtags || []),
            followingNewsletters: ensureValidJSONArray(aiData.followingNewsletters || []),
            interestsIndustries: ensureValidJSONArray(aiData.interestsIndustries || []),
            interestsTopics: ensureValidJSONArray(aiData.interestsTopics || []),
            groups: ensureValidJSONArray(aiData.groups || []),
            featured: ensureValidJSONArray(aiData.featured || []),
            services: ensureValidJSONArray(aiData.services || []),
            engagementData: sanitizeForJSON(engagement),
            creatorInfo: sanitizeForJSON(aiData.creator || {}),
            businessInfo: sanitizeForJSON(aiData.business || {}),
            
            // Raw Gemini data storage
            geminiRawData: sanitizeForJSON(geminiResponse),
            geminiProcessedAt: new Date(),
            geminiTokenUsage: geminiResponse.metadata?.tokenUsage || {},
            
            // Metadata
            timestamp: new Date(),
            dataSource: 'html_scraping_gemini',
            hasExperience: aiData.experience && Array.isArray(aiData.experience) && aiData.experience.length > 0
        };
        
        return processedData;
        
    } catch (error) {
        console.error('Error processing Gemini data for USER profile:', error);
        throw new Error(`Gemini data processing failed: ${error.message}`);
    }
};

// ==================== USER MANAGEMENT FUNCTIONS ====================

const createUser = async (email, passwordHash, packageType = 'free', billingModel = 'monthly') => {
    // Get credits from plans table
    const planResult = await pool.query(
        'SELECT renewable_credits FROM plans WHERE plan_code = $1',
        [packageType]
    );
    
    const renewableCredits = planResult.rows[0]?.renewable_credits || 7;
    
    // ðŸ†• Get context slots for plan
    const planContextSlots = {
        'free': 1,
        'silver-monthly': 3,
        'gold-monthly': 6,
        'platinum-monthly': 10,
        'silver-payasyougo': 1,
        'gold-payasyougo': 1,
        'platinum-payasyougo': 1
    };
    
    const contextSlots = planContextSlots[packageType] || 1;
    
    const result = await pool.query(`
        INSERT INTO users (
            email, password_hash, package_type, billing_model, plan_code,
            renewable_credits, payasyougo_credits, credits_remaining,
            plan_context_slots, extra_context_slots, total_context_slots,
            subscription_starts_at, next_billing_date, is_admin
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) RETURNING *
    `, [
        email, passwordHash, packageType, billingModel, packageType,
        renewableCredits, 0, renewableCredits,
        contextSlots, 0, contextSlots,
        new Date(), new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // Next month
        false // is_admin defaults to false
    ]);
    
    return result.rows[0];
};

// âœ… AUTO-REGISTRATION: Enhanced createGoogleUser with LinkedIn URL support
const createGoogleUser = async (email, displayName, googleId, profilePicture, packageType = 'free', billingModel = 'monthly', linkedinUrl = null) => {
    // Get credits from plans table
    const planResult = await pool.query(
        'SELECT renewable_credits FROM plans WHERE plan_code = $1',
        [packageType]
    );
    
    const renewableCredits = planResult.rows[0]?.renewable_credits || 7;
    
    // ðŸ†• Get context slots for plan
    const planContextSlots = {
        'free': 1,
        'silver-monthly': 3,
        'gold-monthly': 6,
        'platinum-monthly': 10,
        'silver-payasyougo': 1,
        'gold-payasyougo': 1,
        'platinum-payasyougo': 1
    };
    
    const contextSlots = planContextSlots[packageType] || 1;
    
    // âœ… AUTO-REGISTRATION: Set registration_completed = true when LinkedIn URL is provided
    const registrationCompleted = !!linkedinUrl;
    
    const result = await pool.query(`
        INSERT INTO users (
            email, google_id, display_name, profile_picture, 
            package_type, billing_model, plan_code,
            renewable_credits, payasyougo_credits, credits_remaining,
            plan_context_slots, extra_context_slots, total_context_slots,
            subscription_starts_at, next_billing_date,
            linkedin_url, registration_completed, is_admin
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18) RETURNING *
    `, [
        email, googleId, displayName, profilePicture, 
        packageType, billingModel, packageType,
        renewableCredits, 0, renewableCredits,
        contextSlots, 0, contextSlots,
        new Date(), new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // Next month
        linkedinUrl, registrationCompleted, // âœ… AUTO-REGISTRATION: Add LinkedIn URL and registration status
        false // is_admin defaults to false
    ]);
    
    const user = result.rows[0];
    
    return user;
};

const linkGoogleAccount = async (userId, googleId) => {
    const result = await pool.query(
        'UPDATE users SET google_id = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING *',
        [googleId, userId]
    );
    return result.rows[0];
};

const getUserByEmail = async (email) => {
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    return result.rows[0];
};

const getUserById = async (userId) => {
    const result = await pool.query('SELECT * FROM users WHERE id = $1', [userId]);
    return result.rows[0];
};

// USER PROFILE: Create user profile (UNCHANGED - still working)
const createOrUpdateUserProfile = async (userId, linkedinUrl, displayName = null) => {
    try {
        await pool.query(
            'UPDATE users SET linkedin_url = $1, extraction_status = $2, error_message = NULL// ENHANCED database.js - Added Plans Table + Dual Credit System + AUTO-REGISTRATION + GPT-5 MESSAGE LOGGING + CHARGEBEE COLUMNS + PENDING REGISTRATIONS + MESSAGES CAMPAIGN TRACKING + CANCELLATION TRACKING + SAVED CONTEXTS + CONTEXT ADDONS + SECURE ADMIN MANAGEMENT + EMAIL FINDER
// Sophisticated credit management with renewable + pay-as-you-go credits
// FIXED: Resolved SQL arithmetic issues causing "operator is not unique" errors
// FIXED: Changed VARCHAR(500) to TEXT for URL fields to fix authentication errors
// âœ… AUTO-REGISTRATION: Enhanced createGoogleUser to support auto-registration with LinkedIn URL
// âœ… URL DEDUPLICATION FIX: Fixed UNIQUE constraint creation and added duplicate cleanup
// âœ… GPT-5 INTEGRATION: Enhanced message_logs table with comprehensive logging columns
// âœ… FIXED: Added message_type column for connection/intro message differentiation
// âœ… MESSAGE TYPE FIX: Fixed message type detection and insertion logic
// âœ… CHARGEBEE FIX: Added chargebee_subscription_id and chargebee_customer_id columns
// âœ… REGISTRATION FIX: Added pending_registrations table for webhook-based registration completion
// âœ… MESSAGES FIX: Added campaign tracking fields to message_logs table
// âœ… PROMPT VERSION FIX: Increased prompt_version column size from VARCHAR(50) to VARCHAR(255)
// âœ… CANCELLATION FIX: Added cancellation tracking columns for subscription cancellations
// âœ… CONTEXTS FIX: Added saved_contexts table for context management with plan-based limits
// âœ… CONTEXT ADDONS: Added user_context_addons and context_slot_events tables for extra slot subscriptions
// ðŸ†• CONTEXT SLOT SYSTEM: Simplified context slots with direct database fields (like credit system)
// ðŸ”§ INITIALIZATION FIX: Fixed initializeContextSlots to handle both plan_code AND package_type fields
// ðŸ”’ SECURE ADMIN MANAGEMENT: Environment-based, authorized, audited admin management
// âœ… EMAIL FINDER: Added email finder columns to target_profiles table

const { Pool } = require('pg');
require('dotenv').config();

// Database connection pool
const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

// NEW: Clean up duplicate URLs in target_profiles table
const cleanupDuplicateTargetProfiles = async () => {
    try {
        console.log('[CLEANUP] Starting duplicate target profiles cleanup...');
        
        // Find duplicates (keep the earliest one)
        const duplicatesQuery = `
            DELETE FROM target_profiles 
            WHERE id NOT IN (
                SELECT MIN(id) 
                FROM target_profiles 
                GROUP BY linkedin_url, user_id
            )
        `;
        
        const result = await pool.query(duplicatesQuery);
        console.log(`[CLEANUP] Removed ${result.rowCount} duplicate target profiles`);
        
        return result.rowCount;
    } catch (error) {
        console.error('[CLEANUP] Error cleaning up duplicates:', error);
        return 0;
    }
};

// NEW: Ensure target_profiles table exists with proper UNIQUE constraint
const ensureTargetProfilesTable = async () => {
    try {
        console.log('[INIT] Creating target_profiles table...');
        
        // Create target_profiles table if it doesn't exist
        await pool.query(`
            CREATE TABLE IF NOT EXISTS target_profiles (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                linkedin_url TEXT NOT NULL,
                data_json JSONB,
                input_tokens INTEGER,
                output_tokens INTEGER,
                total_tokens INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);
        
        // Clean up any existing duplicates before adding constraint
        await cleanupDuplicateTargetProfiles();
        
        // Add UNIQUE constraint - FIXED: Correct error message
        try {
            await pool.query(`
                ALTER TABLE target_profiles 
                ADD CONSTRAINT target_profiles_linkedin_url_unique 
                UNIQUE (linkedin_url);
            `);
            console.log('[SUCCESS] Added UNIQUE constraint to target_profiles');
        } catch (err) {
            if (err.code === '42P07') {
                console.log('[INFO] UNIQUE constraint already exists on target_profiles');
            } else {
                console.log('[ERROR] UNIQUE constraint creation failed:', err.message);
            }
        }
        
        // Create index for better performance
        try {
            await pool.query(`
                CREATE INDEX IF NOT EXISTS idx_target_profiles_linkedin_url 
                ON target_profiles(linkedin_url);
            `);
            console.log('[SUCCESS] Created index on target_profiles.linkedin_url');
        } catch (err) {
            console.log('[INFO] Index might already exist:', err.message);
        }
        
    } catch (error) {
        console.error('[ERROR] Failed to ensure target_profiles table:', error);
        throw error;
    }
};

// âœ… NEW: Ensure saved_contexts table exists
const ensureSavedContextsTable = async () => {
    try {
        console.log('[INIT] Creating saved_contexts table...');
        
        await pool.query(`
            CREATE TABLE IF NOT EXISTS saved_contexts (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                context_name VARCHAR(100) NOT NULL,
                context_text TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                
                UNIQUE(user_id, context_name)
            );
        `);
        
        try {
            await pool.query(`
                CREATE INDEX IF NOT EXISTS idx_saved_contexts_user_id 
                ON saved_contexts(user_id);
                CREATE INDEX IF NOT EXISTS idx_saved_contexts_created_at 
                ON saved_contexts(created_at);
            `);
            console.log('[SUCCESS] Created saved_contexts indexes');
        } catch (err) {
            console.log('[INFO] Saved contexts indexes might already exist:', err.message);
        }
        
        console.log('[SUCCESS] saved_contexts table ensured');
        
    } catch (error) {
        console.error('[ERROR] Failed to ensure saved_contexts table:', error);
        throw error;
    }
};

// âœ… NEW: Ensure context addon tables exist
const ensureContextAddonTables = async () => {
    try {
        console.log('[INIT] Creating context addon system tables...');
        
        // 1. Create user_context_addons table
        await pool.query(`
            CREATE TABLE IF NOT EXISTS user_context_addons (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                chargebee_subscription_id VARCHAR(255) UNIQUE,
                chargebee_addon_id VARCHAR(255) DEFAULT 'extra-context-slot',
                addon_quantity INTEGER DEFAULT 1,
                monthly_price DECIMAL(8,2) DEFAULT 3.99,
                
                -- Billing cycle tracking
                billing_period_start DATE NOT NULL,
                billing_period_end DATE NOT NULL,
                next_billing_date DATE NOT NULL,
                
                -- Status management
                status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled', 'expired', 'grace_period')),
                chargebee_status VARCHAR(50),
                expires_at TIMESTAMP NULL,
                
                -- Audit fields
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                
                CONSTRAINT unique_chargebee_subscription UNIQUE (chargebee_subscription_id)
            );
        `);

        // 2. Create context_slot_events table
        await pool.query(`
            CREATE TABLE IF NOT EXISTS context_slot_events (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                event_type VARCHAR(30) NOT NULL CHECK (event_type IN ('addon_purchased', 'addon_renewed', 'addon_expired', 'context_saved', 'context_deleted')),
                addon_id INTEGER NULL REFERENCES user_context_addons(id) ON DELETE SET NULL,
                base_limit INTEGER NOT NULL,
                active_extra_slots INTEGER NOT NULL,
                total_limit INTEGER NOT NULL,
                current_usage INTEGER NOT NULL,
                metadata JSONB NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);

        // 3. Add missing columns
        try {
            await pool.query(`ALTER TABLE users ADD COLUMN IF NOT EXISTS contexts_count INTEGER DEFAULT 0;`);
            await pool.query(`ALTER TABLE saved_contexts ADD COLUMN IF NOT EXISTS context_preview VARCHAR(150);`);
        } catch (err) {
            console.log('[INFO] Addon columns might already exist');
        }

        // 4. Create indexes
        await pool.query(`
            CREATE INDEX IF NOT EXISTS idx_user_active_addons ON user_context_addons(user_id, status, next_billing_date);
            CREATE INDEX IF NOT EXISTS idx_billing_due ON user_context_addons(next_billing_date, status);
            CREATE INDEX IF NOT EXISTS idx_chargebee_subscription ON user_context_addons(chargebee_subscription_id);
            CREATE INDEX IF NOT EXISTS idx_user_events ON context_slot_events(user_id, created_at);
            CREATE INDEX IF NOT EXISTS idx_event_type ON context_slot_events(event_type, created_at);
        `);

        // 5. Create trigger function for contexts_count
        await pool.query(`
            CREATE OR REPLACE FUNCTION update_contexts_count()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = 'INSERT' THEN
                    UPDATE users SET contexts_count = contexts_count + 1 WHERE id = NEW.user_id;
                    RETURN NEW;
                ELSIF TG_OP = 'DELETE' THEN
                    UPDATE users SET contexts_count = contexts_count - 1 WHERE id = OLD.user_id;
                    RETURN OLD;
                END IF;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        `);

        // 6. Create trigger
        await pool.query(`
            DROP TRIGGER IF EXISTS contexts_count_trigger ON saved_contexts;
            CREATE TRIGGER contexts_count_trigger
                AFTER INSERT OR DELETE ON saved_contexts
                FOR EACH ROW EXECUTE FUNCTION update_contexts_count();
        `);

        // 7. Initialize contexts_count for existing users
        await pool.query(`
            UPDATE users SET contexts_count = (
                SELECT COUNT(*) FROM saved_contexts WHERE saved_contexts.user_id = users.id
            ) WHERE contexts_count IS NULL OR contexts_count = 0;
        `);

        console.log('[SUCCESS] Context addon system tables created');
        
    } catch (error) {
        console.error('[ERROR] Failed to ensure context addon tables:', error);
        throw error;
    }
};

// âœ… NEW: Ensure pending_registrations table exists
const ensurePendingRegistrationsTable = async () => {
    try {
        console.log('[INIT] Creating pending_registrations table...');
        
        await pool.query(`
            CREATE TABLE IF NOT EXISTS pending_registrations (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                linkedin_url TEXT NOT NULL,
                package_type VARCHAR(50) NOT NULL,
                terms_accepted BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                completed_at TIMESTAMP,
                expired_at TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL '24 hours')
            );
        `);
        
        // Create indexes for fast lookup
        try {
            await pool.query(`
                CREATE INDEX IF NOT EXISTS idx_pending_registrations_user_id 
                ON pending_registrations(user_id);
                CREATE INDEX IF NOT EXISTS idx_pending_registrations_created_at 
                ON pending_registrations(created_at);
            `);
            console.log('[SUCCESS] Created pending_registrations indexes');
        } catch (err) {
            console.log('[INFO] Pending registrations indexes might already exist:', err.message);
        }
        
        console.log('[SUCCESS] pending_registrations table ensured');
        
    } catch (error) {
        console.error('[ERROR] Failed to ensure pending_registrations table:', error);
        throw error;
    }
};

// ðŸ”’ NEW: Ensure admin_audit_log table exists for security tracking
const ensureAdminAuditTable = async () => {
    try {
        console.log('[INIT] Creating admin_audit_log table...');
        
        await pool.query(`
            CREATE TABLE IF NOT EXISTS admin_audit_log (
                id SERIAL PRIMARY KEY,
                action VARCHAR(100) NOT NULL,
                performed_by_user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
                target_user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
                target_email VARCHAR(255),
                details JSONB DEFAULT '{}'::JSONB,
                ip_address INET,
                user_agent TEXT,
                success BOOLEAN NOT NULL,
                error_message TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);
        
        await pool.query(`
            CREATE INDEX IF NOT EXISTS idx_admin_audit_action ON admin_audit_log(action, created_at);
            CREATE INDEX IF NOT EXISTS idx_admin_audit_user ON admin_audit_log(performed_by_user_id, created_at);
            CREATE INDEX IF NOT EXISTS idx_admin_audit_target ON admin_audit_log(target_user_id, created_at);
        `);
        
        console.log('[SUCCESS] admin_audit_log table created');
        
    } catch (error) {
        console.error('[ERROR] Failed to ensure admin_audit_log table:', error);
        throw error;
    }
};

// âœ… NEW: Fix prompt_version column size to accommodate longer prompt versions
const fixPromptVersionColumn = async () => {
    try {
        console.log('[INIT] Updating prompt_version column size...');
        await pool.query(`
            ALTER TABLE message_logs 
            ALTER COLUMN prompt_version TYPE VARCHAR(255);
        `);
        console.log('[SUCCESS] âœ… prompt_version column updated to VARCHAR(255)');
    } catch (error) {
        console.log('[INFO] Column update may have failed:', error.message);
    }
};

// ðŸ†• NEW: Initialize existing users with proper context slots based on their plans - FIXED: Handle both plan_code AND package_type
const initializeContextSlots = async () => {
    try {
        console.log('[INIT] Initializing context slots for existing users...');
        
        // ðŸ”§ FIXED: Use comprehensive CTE approach to handle both field names
        const result = await pool.query(`
            WITH plan_mapping AS (
                SELECT id, 
                       COALESCE(plan_code, package_type, 'free') as effective_plan,
                       CASE 
                           WHEN COALESCE(plan_code, package_type, 'free') = 'silver-monthly' THEN 3
                           WHEN COALESCE(plan_code, package_type, 'free') = 'gold-monthly' THEN 6
                           WHEN COALESCE(plan_code, package_type, 'free') = 'platinum-monthly' THEN 10
                           WHEN COALESCE(plan_code, package_type, 'free') LIKE '%-payasyougo' THEN 1
                           ELSE 1  -- free and unknown plans default to 1
                       END as correct_base_slots
                FROM users
            )
            UPDATE users 
            SET plan_context_slots = plan_mapping.correct_base_slots,
                total_context_slots = plan_mapping.correct_base_slots + COALESCE(users.extra_context_slots, 0),
                updated_at = CURRENT_TIMESTAMP
            FROM plan_mapping 
            WHERE users.id = plan_mapping.id
            AND (users.plan_context_slots IS NULL 
                 OR users.plan_context_slots != plan_mapping.correct_base_slots 
                 OR users.plan_context_slots = 1) -- Force update even existing 1s to ensure correct values
        `);
        
        console.log(`[INIT] âœ… Updated ${result.rowCount} users with correct context slots`);
        
        // ðŸ”§ VERIFICATION: Log the results for verification
        const verification = await pool.query(`
            SELECT 
                COALESCE(plan_code, package_type, 'unknown') as effective_plan,
                plan_context_slots,
                COUNT(*) as user_count
            FROM users 
            GROUP BY effective_plan, plan_context_slots
            ORDER BY effective_plan, plan_context_slots
        `);
        
        console.log('[INIT] Context slots verification results:');
        verification.rows.forEach(row => {
            console.log(`  ${row.effective_plan}: ${row.plan_context_slots} slots (${row.user_count} users)`);
        });
        
        console.log('[SUCCESS] âœ… Context slots initialization completed successfully');
        
    } catch (error) {
        console.error('[ERROR] Failed to initialize context slots:', error);
    }
};

// âœ… NEW: Fix message types for existing messages
const fixExistingMessageTypes = async () => {
    try {
        console.log('[INIT] Fixing message types for existing messages...');
        
        // Update connection request messages
        const connectionResult = await pool.query(`
            UPDATE message_logs 
            SET message_type = 'connection_request' 
            WHERE message_type = 'message' 
            AND (
                LOWER(generated_message) LIKE '%connect%' 
                OR LOWER(generated_message) LIKE '%connection%'
                OR LOWER(generated_message) LIKE '%network%'
                OR LOWER(generated_message) LIKE '%linkedin%'
            )
        `);
        
        // Update cold email messages
        const emailResult = await pool.query(`
            UPDATE message_logs 
            SET message_type = 'cold_email' 
            WHERE message_type = 'message' 
            AND (
                LOWER(generated_message) LIKE 'subject:%' 
                OR LOWER(generated_message) LIKE '%dear %'
                OR LOWER(generated_message) LIKE '%email%'
                OR LOWER(generated_message) LIKE '%regards%'
                OR LOWER(generated_message) LIKE '%sincerely%'
            )
        `);
        
        // Keep remaining as linkedin_message
        const linkedinResult = await pool.query(`
            UPDATE message_logs 
            SET message_type = 'linkedin_message' 
            WHERE message_type = 'message'
        `);
        
        console.log(`[SUCCESS] Fixed message types: ${connectionResult.rowCount} connection requests, ${emailResult.rowCount} cold emails, ${linkedinResult.rowCount} LinkedIn messages`);
        
    } catch (error) {
        console.error('[ERROR] Failed to fix existing message types:', error);
    }
};

// ðŸ”’ SECURE ADMIN MANAGEMENT FUNCTIONS

// ðŸ”’ Security: Audit logging function
const logAdminAction = async (action, performedByUserId, targetUserId, targetEmail, details = {}, success = true, errorMessage = null, ipAddress = null, userAgent = null) => {
    try {
        await pool.query(`
            INSERT INTO admin_audit_log (
                action, performed_by_user_id, target_user_id, target_email, 
                details, ip_address, user_agent, success, error_message
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `, [action, performedByUserId, targetUserId, targetEmail, JSON.stringify(details), ipAddress, userAgent, success, errorMessage]);
    } catch (error) {
        console.error('[AUDIT] Failed to log admin action:', error);
    }
};

// ðŸ”’ Security: Authorization middleware
const requireAdminAuthorization = async (performingUserId) => {
    try {
        if (!performingUserId) {
            throw new Error('No user ID provided for authorization');
        }
        
        const result = await pool.query(
            'SELECT id, email, is_admin FROM users WHERE id = $1',
            [performingUserId]
        );
        
        if (result.rows.length === 0) {
            throw new Error('User not found');
        }
        
        const user = result.rows[0];
        if (!user.is_admin) {
            throw new Error('Admin access required');
        }
        
        return user;
    } catch (error) {
        console.error('[AUTH] Admin authorization failed:', error);
        throw new Error('Unauthorized');
    }
};

// ðŸ”’ Security: Input sanitization
const sanitizeEmail = (email) => {
    if (!email || typeof email !== 'string') {
        throw new Error('Invalid email format');
    }
    const sanitized = email.toLowerCase().trim();
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(sanitized)) {
        throw new Error('Invalid email format');
    }
    return sanitized;
};

// ðŸ”’ SECURE: Create admin user (requires authorization)
const createAdminUser = async (email, performingUserId, password = null, displayName = null, auditInfo = {}) => {
    let sanitizedEmail;
    try {
        // Security: Authorize the request
        const performingUser = await requireAdminAuthorization(performingUserId);
        
        // Security: Sanitize input
        sanitizedEmail = sanitizeEmail(email);
        
        console.log(`[ADMIN] Authorized admin ${performingUser.email} creating admin user: ${sanitizedEmail}`);
        
        // Check if user already exists
        const existingUser = await pool.query(
            'SELECT id, email, is_admin FROM users WHERE email = $1',
            [sanitizedEmail]
        );
        
        if (existingUser.rows.length > 0) {
            const user = existingUser.rows[0];
            if (user.is_admin) {
                await logAdminAction('create_admin_user_already_exists', performingUserId, user.id, sanitizedEmail, { existing: true }, true, null, auditInfo.ipAddress, auditInfo.userAgent);
                return {
                    success: true,
                    message: 'User is already admin',
                    user: { id: user.id, email: user.email, is_admin: user.is_admin }
                };
            } else {
                // Promote existing user to admin
                return await promoteUserToAdmin(sanitizedEmail, performingUserId, auditInfo);
            }
        }
        
        // Create new admin user
        const result = await pool.query(`
            INSERT INTO users (
                email, 
                display_name, 
                password_hash, 
                package_type, 
                billing_model, 
                plan_code,
                renewable_credits, 
                payasyougo_credits, 
                credits_remaining,
                plan_context_slots, 
                extra_context_slots, 
                total_context_slots,
                subscription_starts_at, 
                next_billing_date,
                is_admin,
                registration_completed
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16) 
            RETURNING id, email, display_name, is_admin
        `, [
            sanitizedEmail,
            displayName || 'Admin User',
            password, // Can be null for OAuth users
            'free',
            'monthly',
            'free',
            7, 0, 7, // Credits
            1, 0, 1, // Context slots
            new Date(),
            new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // Next month
            true, // is_admin
            true  // registration_completed
        ]);
        
        const newUser = result.rows[0];
        
        // Security: Log the action
        await logAdminAction('create_admin_user', performingUserId, newUser.id, sanitizedEmail, { created: true }, true, null, auditInfo.ipAddress, auditInfo.userAgent);
        
        console.log(`[ADMIN] âœ… Admin ${performingUser.email} created new admin user: ${sanitizedEmail} (ID: ${newUser.id})`);
        
        return {
            success: true,
            message: 'Admin user created successfully',
            user: newUser
        };
        
    } catch (error) {
        console.error(`[ADMIN] Error creating admin user ${sanitizedEmail}:`, error);
        
        // Security: Log failed attempt
        await logAdminAction('create_admin_user_failed', performingUserId, null, sanitizedEmail, { error: 'Creation failed' }, false, error.message, auditInfo.ipAddress, auditInfo.userAgent);
        
        return {
            success: false,
            error: 'Failed to create admin user'
        };
    }
};

// ðŸ”’ SECURE: Promote user to admin (requires authorization)
const promoteUserToAdmin = async (email, performingUserId, auditInfo = {}) => {
    let sanitizedEmail;
    try {
        // Security: Authorize the request
        const performingUser = await requireAdminAuthorization(performingUserId);
        
        // Security: Sanitize input
        sanitizedEmail = sanitizeEmail(email);
        
        console.log(`[ADMIN] Authorized admin ${performingUser.email} promoting user to admin: ${sanitizedEmail}`);
        
        const result = await pool.query(`
            UPDATE users 
            SET is_admin = TRUE, updated_at = CURRENT_TIMESTAMP
            WHERE email = $1
            RETURNING id, email, display_name, is_admin
        `, [sanitizedEmail]);
        
        if (result.rows.length === 0) {
            await logAdminAction('promote_user_not_found', performingUserId, null, sanitizedEmail, { error: 'User not found' }, false, 'User not found', auditInfo.ipAddress, auditInfo.userAgent);
            return {
                success: false,
                error: 'User not found'
            };
        }
        
        const user = result.rows[0];
        
        // Security: Log the action
        await logAdminAction('promote_user_to_admin', performingUserId, user.id, sanitizedEmail, { promoted: true }, true, null, auditInfo.ipAddress, auditInfo.userAgent);
        
        console.log(`[ADMIN] âœ… Admin ${performingUser.email} promoted user to admin: ${sanitizedEmail} (ID: ${user.id})`);
        
        return {
            success: true,
            message: 'User promoted to admin successfully',
            user: user
        };
        
    } catch (error) {
        console.error(`[ADMIN] Error promoting user to admin ${sanitizedEmail}:`, error);
        
        // Security: Log failed attempt
        await logAdminAction('promote_user_failed', performingUserId, null, sanitizedEmail, { error: 'Promotion failed' }, false, error.message, auditInfo.ipAddress, auditInfo.userAgent);
        
        return {
            success: false,
            error: 'Unauthorized or promotion failed'
        };
    }
};

// ðŸ”’ SECURE: Remove admin rights (requires authorization)
const removeAdminRights = async (email, performingUserId, auditInfo = {}) => {
    let sanitizedEmail;
    try {
        // Security: Authorize the request
        const performingUser = await requireAdminAuthorization(performingUserId);
        
        // Security: Sanitize input
        sanitizedEmail = sanitizeEmail(email);
        
        // Security: Prevent self-demotion
        if (performingUser.email === sanitizedEmail) {
            await logAdminAction('remove_admin_self_attempt', performingUserId, performingUser.id, sanitizedEmail, { error: 'Self-demotion prevented' }, false, 'Cannot remove own admin rights', auditInfo.ipAddress, auditInfo.userAgent);
            return {
                success: false,
                error: 'Cannot remove your own admin rights'
            };
        }
        
        console.log(`[ADMIN] Authorized admin ${performingUser.email} removing admin rights from: ${sanitizedEmail}`);
        
        const result = await pool.query(`
            UPDATE users 
            SET is_admin = FALSE, updated_at = CURRENT_TIMESTAMP
            WHERE email = $1
            RETURNING id, email, display_name, is_admin
        `, [sanitizedEmail]);
        
        if (result.rows.length === 0) {
            await logAdminAction('remove_admin_not_found', performingUserId, null, sanitizedEmail, { error: 'User not found' }, false, 'User not found', auditInfo.ipAddress, auditInfo.userAgent);
            return {
                success: false,
                error: 'User not found'
            };
        }
        
        const user = result.rows[0];
        
        // Security: Log the action
        await logAdminAction('remove_admin_rights', performingUserId, user.id, sanitizedEmail, { demoted: true }, true, null, auditInfo.ipAddress, auditInfo.userAgent);
        
        console.log(`[ADMIN] âœ… Admin ${performingUser.email} removed admin rights from: ${sanitizedEmail} (ID: ${user.id})`);
        
        return {
            success: true,
            message: 'Admin rights removed successfully',
            user: user
        };
        
    } catch (error) {
        console.error(`[ADMIN] Error removing admin rights from ${sanitizedEmail}:`, error);
        
        // Security: Log failed attempt
        await logAdminAction('remove_admin_failed', performingUserId, null, sanitizedEmail, { error: 'Removal failed' }, false, error.message, auditInfo.ipAddress, auditInfo.userAgent);
        
        return {
            success: false,
            error: 'Unauthorized or removal failed'
        };
    }
};

// ðŸ”’ SECURE: List admin users (requires authorization)
const listAdminUsers = async (performingUserId, auditInfo = {}) => {
    try {
        // Security: Authorize the request
        const performingUser = await requireAdminAuthorization(performingUserId);
        
        const result = await pool.query(`
            SELECT id, email, display_name, is_admin, created_at, updated_at
            FROM users 
            WHERE is_admin = TRUE
            ORDER BY created_at ASC
        `);
        
        // Security: Log the action
        await logAdminAction('list_admin_users', performingUserId, null, null, { count: result.rows.length }, true, null, auditInfo.ipAddress, auditInfo.userAgent);
        
        console.log(`[ADMIN] Admin ${performingUser.email} listed ${result.rows.length} admin users`);
        
        return {
            success: true,
            adminUsers: result.rows.map(user => ({
                id: user.id,
                email: user.email,
                display_name: user.display_name,
                created_at: user.created_at
            }))
        };
        
    } catch (error) {
        console.error('[ADMIN] Error listing admin users:', error);
        
        // Security: Log failed attempt
        await logAdminAction('list_admin_failed', performingUserId, null, null, { error: 'List failed' }, false, error.message, auditInfo.ipAddress, auditInfo.userAgent);
        
        return {
            success: false,
            error: 'Unauthorized'
        };
    }
};

// ðŸ”’ SECURE: Manual admin setup function (requires environment variable)
const setupInitialAdmin = async (requireConfirmation = true) => {
    try {
        const adminEmail = process.env.INITIAL_ADMIN_EMAIL;
        
        if (!adminEmail) {
            console.log('[ADMIN] No INITIAL_ADMIN_EMAIL environment variable set. Skipping initial admin setup.');
            console.log('[ADMIN] To create an admin user, set INITIAL_ADMIN_EMAIL=email@example.com in your environment');
            return { success: false, message: 'No admin email configured' };
        }
        
        if (requireConfirmation) {
            console.log(`[ADMIN] MANUAL SETUP REQUIRED: To create initial admin user ${adminEmail}:`);
            console.log('[ADMIN] 1. Set ADMIN_SETUP_CONFIRMED=true in your environment');
            console.log('[ADMIN] 2. Restart your application');
            console.log('[ADMIN] 3. The admin user will be created automatically');
            return { success: false, message: 'Manual confirmation required' };
        }
        
        const confirmed = process.env.ADMIN_SETUP_CONFIRMED === 'true';
        if (!confirmed) {
            console.log(`[ADMIN] ADMIN_SETUP_CONFIRMED not set to 'true'. Skipping admin creation for ${adminEmail}`);
            return { success: false, message: 'Setup not confirmed' };
        }
        
        console.log(`[ADMIN] Creating initial admin user: ${adminEmail}`);
        
        // Check if user already exists
        const existingUser = await pool.query(
            'SELECT id, email, is_admin FROM users WHERE email = $1',
            [adminEmail.toLowerCase().trim()]
        );
        
        if (existingUser.rows.length > 0) {
            const user = existingUser.rows[0];
            if (user.is_admin) {
                console.log(`[ADMIN] âœ… ${adminEmail} is already admin`);
                return { success: true, message: 'User is already admin', user: user };
            } else {
                // Promote existing user (without authorization check for initial setup)
                const result = await pool.query(`
                    UPDATE users 
                    SET is_admin = TRUE, updated_at = CURRENT_TIMESTAMP
                    WHERE email = $1
                    RETURNING id, email, display_name, is_admin
                `, [adminEmail.toLowerCase().trim()]);
                
                const updatedUser = result.rows[0];
                await logAdminAction('initial_admin_promotion', null, updatedUser.id, adminEmail, { initial_setup: true }, true);
                console.log(`[ADMIN] âœ… Promoted existing user to admin: ${adminEmail}`);
                return { success: true, message: 'User promoted to admin', user: updatedUser };
            }
        } else {
            // Create new admin user (without authorization check for initial setup)
            const result = await pool.query(`
                INSERT INTO users (
                    email, display_name, package_type, billing_model, plan_code,
                    renewable_credits, payasyougo_credits, credits_remaining,
                    plan_context_slots, extra_context_slots, total_context_slots,
                    subscription_starts_at, next_billing_date, is_admin, registration_completed
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) 
                RETURNING id, email, display_name, is_admin
            `, [
                adminEmail.toLowerCase().trim(),
                'Initial Admin User',
                'free', 'monthly', 'free',
                7, 0, 7, // Credits
                1, 0, 1, // Context slots
                new Date(), new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // Next month
                true, true // is_admin, registration_completed
            ]);
            
            const newUser = result.rows[0];
            await logAdminAction('initial_admin_creation', null, newUser.id, adminEmail, { initial_setup: true }, true);
            console.log(`[ADMIN] âœ… Created initial admin user: ${adminEmail} (ID: ${newUser.id})`);
            return { success: true, message: 'Initial admin user created', user: newUser };
        }
        
    } catch (error) {
        console.error('[ADMIN] Error in initial admin setup:', error);
        return { success: false, error: 'Initial admin setup failed' };
    }
};

// âœ… NEW: Message log creation with IMPROVED message type detection
const createMessageLog = async (userId, messageData) => {
    try {
        // IMPROVED: Enhanced message type detection with better patterns
        const detectMessageType = (message) => {
            const content = (message || '').toLowerCase().trim();
            
            // Cold email detection (more comprehensive)
            if (content.includes('subject:') || 
                content.match(/^subject\s*:/i) ||
                content.includes('dear ') || 
                content.includes('regards') || 
                content.includes('sincerely') ||
                content.includes('best regards') ||
                content.includes('kind regards') ||
                content.includes('yours truly') ||
                content.match(/@\w+\.\w+/)) { // email pattern
                return 'cold_email';
            }
            
            // Connection request detection (more specific patterns)
            if (content.includes('connect') || 
                content.includes('connection') || 
                content.includes('network') ||
                content.includes('would love to connect') ||
                content.includes('love to connect') ||
                content.includes('add you to my network') ||
                content.includes('connect with you') ||
                content.includes('sending you a connection')) {
                return 'connection_request';
            }
            
            // Default to LinkedIn message
            return 'linkedin_message';
        };
        
        const messageType = detectMessageType(messageData.generated_message);
        
        const result = await pool.query(`
            INSERT INTO message_logs (
                user_id, target_name, target_url, target_profile_url,
                generated_message, message_context, credits_used,
                context_text, target_first_name, target_title, target_company,
                model_name, prompt_version, input_tokens, output_tokens, 
                total_tokens, latency_ms, data_json, message_type,
                sent_status, reply_status, comments
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)
            RETURNING *
        `, [
            userId,
            messageData.target_name,
            messageData.target_url,
            messageData.target_profile_url,
            messageData.generated_message,
            messageData.message_context,
            messageData.credits_used || 1,
            messageData.context_text,
            messageData.target_first_name,
            messageData.target_title,
            messageData.target_company,
            messageData.model_name,
            messageData.prompt_version,
            messageData.input_tokens,
            messageData.output_tokens,
            messageData.total_tokens,
            messageData.latency_ms,
            messageData.data_json ? JSON.stringify(messageData.data_json) : null,
            messageType, // âœ… IMPROVED: Better message type detection
            messageData.sent_status || 'pending',
            messageData.reply_status || 'pending',
            messageData.comments
        ]);
        
        console.log(`[MESSAGE_LOG] Created ${messageType} message log for user ${userId}`);
        
        return {
            success: true,
            data: result.rows[0]
        };
        
    } catch (error) {
        console.error('Error creating message log:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// âœ… NEW: Format email message for display (separate subject and body)
const formatEmailMessage = (message) => {
    if (!message) return { subject: '', body: '' };
    
    const content = message.trim();
    
    // Check if message has "Subject:" format
    const subjectMatch = content.match(/^subject:\s*(.+?)[\r\n]+(.*)/is);
    if (subjectMatch) {
        return {
            subject: subjectMatch[1].trim(),
            body: subjectMatch[2].trim()
        };
    }
    
    // If no clear subject line, treat whole message as body
    return {
        subject: 'Professional Outreach',
        body: content
    };
};

// âœ… NEW: Get formatted messages for display
const getFormattedMessages = async (userId) => {
    try {
        const result = await pool.query(`
            SELECT 
                ml.*,
                tp.email_found,
                tp.email_status,
                tp.email_verified_at
            FROM message_logs ml
            LEFT JOIN target_profiles tp ON ml.target_profile_url = tp.linkedin_url
            WHERE ml.user_id = $1
            ORDER BY ml.created_at DESC
        `, [userId]);
        
        // Format messages with proper email structure
        const formattedMessages = result.rows.map(message => {
            if (message.message_type === 'cold_email') {
                const emailFormat = formatEmailMessage(message.generated_message);
                return {
                    ...message,
                    email_subject: emailFormat.subject,
                    email_body: emailFormat.body,
                    formatted_message: `Subject: ${emailFormat.subject}\n\n${emailFormat.body}`
                };
            }
            return {
                ...message,
                formatted_message: message.generated_message
            };
        });
        
        return {
            success: true,
            data: formattedMessages
        };
        
    } catch (error) {
        console.error('Error getting formatted messages:', error);
        return {
            success: false,
            error: error.message
        };
    }
};

// ==================== DATABASE INITIALIZATION ====================

const initDB = async () => {
    try {
        console.log('Creating enhanced database tables with dual credit system + GPT-5 message logging + CHARGEBEE COLUMNS + PENDING REGISTRATIONS + MESSAGES CAMPAIGN TRACKING + CANCELLATION TRACKING + SAVED CONTEXTS + CONTEXT ADDONS + SIMPLIFIED CONTEXT SLOTS + SECURE ADMIN MANAGEMENT + EMAIL FINDER...');

        // PLANS TABLE - FIXED: Drop and recreate with correct schema
        await pool.query(`DROP TABLE IF EXISTS plans CASCADE;`);
        
        await pool.query(`
            CREATE TABLE plans (
                id SERIAL PRIMARY KEY,
                plan_code VARCHAR(50) UNIQUE NOT NULL,
                plan_name VARCHAR(100) NOT NULL,
                billing_model VARCHAR(20) NOT NULL,
                price_cents INTEGER NOT NULL,
                currency VARCHAR(3) DEFAULT 'USD',
                renewable_credits INTEGER NOT NULL,
                is_pay_as_you_go BOOLEAN DEFAULT FALSE,
                description TEXT,
                features JSONB DEFAULT '[]'::JSONB,
                active BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);

        // INSERT REAL PLAN DATA (from sign-up.html)
        await pool.query(`
            INSERT INTO plans (plan_code, plan_name, billing_model, price_cents, renewable_credits, is_pay_as_you_go, description) 
            VALUES 
                ('free', 'Free', 'monthly', 0, 7, FALSE, 'Free plan with 7 monthly renewable credits'),
                ('silver-monthly', 'Silver Monthly', 'monthly', 1390, 30, FALSE, 'Silver monthly plan with 30 renewable credits'),
                ('silver-payasyougo', 'Silver Pay-as-you-go', 'one_time', 1700, 30, TRUE, 'Silver one-time purchase of 30 non-expiring credits'),
                ('gold-monthly', 'Gold Monthly', 'monthly', 3200, 100, FALSE, 'Gold monthly plan with 100 renewable credits'),
                ('gold-payasyougo', 'Gold Pay-as-you-go', 'one_time', 3900, 100, TRUE, 'Gold one-time purchase of 100 non-expiring credits'),
                ('platinum-monthly', 'Platinum Monthly', 'monthly', 6387, 250, FALSE, 'Platinum monthly plan with 250 renewable credits'),
                ('platinum-payasyougo', 'Platinum Pay-as-you-go', 'one_time', 7800, 250, TRUE, 'Platinum one-time purchase of 250 non-expiring credits')
            ON CONFLICT (plan_code) DO UPDATE SET
                plan_name = EXCLUDED.plan_name,
                price_cents = EXCLUDED.price_cents,
                renewable_credits = EXCLUDED.renewable_credits,
                updated_at = CURRENT_TIMESTAMP;
        `);

        // ENHANCED USERS TABLE - FIXED: Changed profile_picture VARCHAR(500) to TEXT + ADDED CHARGEBEE COLUMNS + ðŸ†• CONTEXT SLOT FIELDS + ðŸ”’ ADMIN COLUMN
        await pool.query(`
            CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                email VARCHAR(255) UNIQUE NOT NULL,
                password_hash VARCHAR(255),
                google_id VARCHAR(255) UNIQUE,
                display_name VARCHAR(255),
                profile_picture TEXT,
                first_name VARCHAR(100),
                last_name VARCHAR(100),
                package_type VARCHAR(50) DEFAULT 'free',
                billing_model VARCHAR(50) DEFAULT 'monthly',
                
                -- NEW: Dual Credit System
                plan_code VARCHAR(50) DEFAULT 'free' REFERENCES plans(plan_code),
                renewable_credits INTEGER DEFAULT 7,
                payasyougo_credits INTEGER DEFAULT 0,
                
                -- ðŸ†• NEW: Direct Context Slot Fields (like credit system)
                plan_context_slots INTEGER DEFAULT 1,
                extra_context_slots INTEGER DEFAULT 0,
                total_context_slots INTEGER DEFAULT 1,
                contexts_count INTEGER DEFAULT 0,
                
                -- ðŸ”’ NEW: Admin Management
                is_admin BOOLEAN DEFAULT FALSE,
                
                -- NEW: Billing Cycle Management
                subscription_starts_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                next_billing_date TIMESTAMP,
                
                -- âœ… CHARGEBEE FIX: Add missing Chargebee columns
                chargebee_subscription_id VARCHAR(100) UNIQUE,
                chargebee_customer_id VARCHAR(100),
                
                -- Legacy field (will be calculated from dual credits)
                credits_remaining INTEGER DEFAULT 7,
                
                subscription_status VARCHAR(50) DEFAULT 'active',
                linkedin_url TEXT,
                profile_data JSONB,
                extraction_status VARCHAR(50) DEFAULT 'not_started',
                error_message TEXT,
                registration_completed BOOLEAN DEFAULT false,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);

        // USER_PROFILES TABLE - FIXED: Changed profile_image_url VARCHAR(500) to TEXT
        await pool.query(`
            CREATE TABLE IF NOT EXISTS user_profiles (
                id SERIAL PRIMARY KEY,
                user_id INTEGER UNIQUE REFERENCES users(id) ON DELETE CASCADE,
                
                -- Initial scraping completion flag
                initial_scraping_done BOOLEAN DEFAULT false,
                
                -- Basic Profile Information
                linkedin_url TEXT,
                linkedin_id TEXT,
                linkedin_num_id BIGINT,
                input_url TEXT,
                url TEXT,
                full_name TEXT,
                first_name TEXT,
                last_name TEXT,
                headline TEXT,
                current_job_title TEXT,
                about TEXT,
                summary TEXT,
                
                -- Location Information
                location TEXT,
                city TEXT,
                state TEXT,
                country TEXT,
                country_code TEXT,
                
                -- Professional Information
                industry TEXT,
                current_company TEXT,
                current_company_name TEXT,
                current_company_id TEXT,
                current_company_company_id TEXT,
                current_position TEXT,
                
                -- Enhanced Metrics
                connections_count INTEGER,
                followers_count INTEGER,
                mutual_connections_count INTEGER DEFAULT 0,
                connections INTEGER,
                followers INTEGER,
                recommendations_count INTEGER,
                total_likes INTEGER DEFAULT 0,
                total_comments INTEGER DEFAULT 0,
                total_shares INTEGER DEFAULT 0,
                average_likes DECIMAL(10,2) DEFAULT 0,
                
                -- Media - FIXED: Changed profile_image_url VARCHAR(500) to TEXT
                profile_picture TEXT,
                profile_image_url TEXT,
                avatar TEXT,
                banner_image TEXT,
                background_image_url TEXT,
                
                -- Identifiers
                public_identifier VARCHAR(255),
                
                -- Complex Data Arrays (ALL JSONB)
                experience JSONB DEFAULT '[]'::JSONB,
                education JSONB DEFAULT '[]'::JSONB,
                educations_details JSONB DEFAULT '[]'::JSONB,
                skills JSONB DEFAULT '[]'::JSONB,
                skills_with_endorsements JSONB DEFAULT '[]'::JSONB,
                languages JSONB DEFAULT '[]'::JSONB,
                certifications JSONB DEFAULT '[]'::JSONB,
                courses JSONB DEFAULT '[]'::JSONB,
                projects JSONB DEFAULT '[]'::JSONB,
                publications JSONB DEFAULT '[]'::JSONB,
                patents JSONB DEFAULT '[]'::JSONB,
                volunteer_experience JSONB DEFAULT '[]'::JSONB,
                volunteering JSONB DEFAULT '[]'::JSONB,
                honors_and_awards JSONB DEFAULT '[]'::JSONB,
                awards JSONB DEFAULT '[]'::JSONB,
                organizations JSONB DEFAULT '[]'::JSONB,
                recommendations JSONB DEFAULT '[]'::JSONB,
                recommendations_given JSONB DEFAULT '[]'::JSONB,
                recommendations_received JSONB DEFAULT '[]'::JSONB,
                posts JSONB DEFAULT '[]'::JSONB,
                activity JSONB DEFAULT '[]'::JSONB,
                articles JSONB DEFAULT '[]'::JSONB,
                people_also_viewed JSONB DEFAULT '[]'::JSONB,
                engagement_data JSONB DEFAULT '{}'::JSONB,
                
                -- Additional fields for complete LinkedIn data
                following_companies JSONB DEFAULT '[]'::JSONB,
                following_people JSONB DEFAULT '[]'::JSONB,
                following_hashtags JSONB DEFAULT '[]'::JSONB,
                following_newsletters JSONB DEFAULT '[]'::JSONB,
                interests_industries JSONB DEFAULT '[]'::JSONB,
                interests_topics JSONB DEFAULT '[]'::JSONB,
                groups JSONB DEFAULT '[]'::JSONB,
                featured JSONB DEFAULT '[]'::JSONB,
                creator_info JSONB DEFAULT '{}'::JSONB,
                services JSONB DEFAULT '[]'::JSONB,
                business_info JSONB DEFAULT '{}'::JSONB,
                
                -- RAW GEMINI DATA STORAGE FOR GPT 5 NANO
                gemini_raw_data JSONB,
                gemini_processed_at TIMESTAMP,
                gemini_token_usage JSONB DEFAULT '{}'::JSONB,
                
                -- TOKEN TRACKING COLUMNS
                raw_gpt_response TEXT,
                input_tokens INTEGER,
                output_tokens INTEGER,
                total_tokens INTEGER,
                processing_time_ms INTEGER,
                api_request_id TEXT,
                response_status TEXT DEFAULT 'success',
                
                -- Metadata
                timestamp TIMESTAMP,
                data_source VARCHAR(100),
                data_extraction_status VARCHAR(50) DEFAULT 'pending',
                extraction_attempted_at TIMESTAMP,
                extraction_completed_at TIMESTAMP,
                extraction_error TEXT,
                extraction_retry_count INTEGER DEFAULT 0,
                profile_analyzed BOOLEAN DEFAULT false,
                created_at TIMESTAMP DEFAULT NOW(),
                updated_at TIMESTAMP DEFAULT NOW(),
                
                CONSTRAINT user_profiles_user_id_key UNIQUE (user_id)
            );
        `);

        // ENHANCED MESSAGE_LOGS TABLE - âœ… GPT-5 INTEGRATION: Added comprehensive logging columns + CAMPAIGN TRACKING
        await pool.query(`
            CREATE TABLE IF NOT EXISTS message_logs (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id),
                
                -- Basic message data
                target_name VARCHAR(255),
                target_url TEXT,
                target_profile_url TEXT,
                generated_message TEXT,
                message_context TEXT,
                credits_used INTEGER DEFAULT 1,
                
                -- âœ… NEW: GPT-5 Integration columns
                context_text TEXT,
                target_first_name VARCHAR(255),
                target_title VARCHAR(500),
                target_company VARCHAR(500),
                model_name VARCHAR(100),
                prompt_version VARCHAR(255),
                input_tokens INTEGER,
                output_tokens INTEGER,
                total_tokens INTEGER,
                latency_ms INTEGER,
                data_json JSONB,
                
                -- âœ… FIXED: Message type with proper detection
                message_type VARCHAR(50) DEFAULT 'linkedin_message' CHECK (message_type IN ('linkedin_message', 'connection_request', 'cold_email')),
                
                -- âœ… NEW: Campaign tracking fields for Messages page
                sent_status VARCHAR(20) DEFAULT 'pending',
                reply_status VARCHAR(20) DEFAULT 'pending',
                comments TEXT,
                sent_date TIMESTAMP,
                reply_date TIMESTAMP,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        `);

        // CREDITS_TRANSACTIONS TABLE - FIXED: Drop and recreate with correct schema
        await pool.query(`DROP TABLE IF EXISTS credits_transactions CASCADE;`);
        
        await pool.query(`
            CREATE TABLE IF NOT EXISTS credits_transactions (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id),
                operation_type VARCHAR(50),
                amount DECIMAL(10,2),
                status VARCHAR(20),
                hold_id VARCHAR(100),
                operation_data JSONB,
                operation_result JSONB,
                processing_time_ms INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                completed_at TIMESTAMP
            );
        `);

        // NEW: TARGET_PROFILES TABLE with proper UNIQUE constraint
        await ensureTargetProfilesTable();
        
        // âœ… NEW: SAVED_CONTEXTS TABLE for context management
        await ensureSavedContextsTable();
        
        // âœ… NEW: CONTEXT ADDON TABLES for extra slot subscriptions
        await ensureContextAddonTables();
        
        // âœ… NEW: PENDING_REGISTRATIONS TABLE for webhook-based registration
        await ensurePendingRegistrationsTable();
        
        // ðŸ”’ NEW: ADMIN_AUDIT_LOG TABLE for security tracking
        await ensureAdminAuditTable();

        // âœ… NEW: Fix prompt_version column size to accommodate longer prompt versions
        await fixPromptVersionColumn();

        // Add missing columns (safe operation) + CHARGEBEE COLUMNS + MESSAGES CAMPAIGN TRACKING + CANCELLATION TRACKING + ðŸ†• CONTEXT SLOT FIELDS + ðŸ”’ ADMIN COLUMN
        try {
            const enhancedUserColumns = [
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS google_id VARCHAR(255) UNIQUE',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS display_name VARCHAR(255)',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS profile_picture TEXT',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS first_name VARCHAR(100)',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS last_name VARCHAR(100)',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS linkedin_url TEXT',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS profile_data JSONB',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS extraction_status VARCHAR(50) DEFAULT \'not_started\'',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS error_message TEXT',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS registration_completed BOOLEAN DEFAULT false',
                
                // NEW: Dual Credit System columns
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS plan_code VARCHAR(50) DEFAULT \'free\'',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS renewable_credits INTEGER DEFAULT 7',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS payasyougo_credits INTEGER DEFAULT 0',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS subscription_starts_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS next_billing_date TIMESTAMP',
                
                // ðŸ†• NEW: Context Slot System columns (like credit system)
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS plan_context_slots INTEGER DEFAULT 1',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS extra_context_slots INTEGER DEFAULT 0',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS total_context_slots INTEGER DEFAULT 1',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS contexts_count INTEGER DEFAULT 0',
                
                // ðŸ”’ NEW: Admin Management column
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS is_admin BOOLEAN DEFAULT FALSE',
                
                // âœ… CHARGEBEE FIX: Add missing Chargebee columns
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS chargebee_subscription_id VARCHAR(100) UNIQUE',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS chargebee_customer_id VARCHAR(100)',
                
                // âœ… CANCELLATION FIX: Add cancellation tracking columns
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS cancellation_scheduled_at TIMESTAMP',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS cancellation_effective_date TIMESTAMP',
                'ALTER TABLE users ADD COLUMN IF NOT EXISTS previous_plan_code VARCHAR(50)'
            ];
            
            console.log('-- NEW: Dual Credit System columns + CHARGEBEE COLUMNS + CANCELLATION TRACKING + ðŸ†• CONTEXT SLOT FIELDS + ðŸ”’ ADMIN COLUMN');
            
            for (const columnQuery of enhancedUserColumns) {
                try {
                    await pool.query(columnQuery);
                    // Log context slot column additions
                    if (columnQuery.includes('plan_context_slots')) {
                        console.log('ðŸ†• CONTEXT SLOTS: Added plan_context_slots column');
                    }
                    if (columnQuery.includes('extra_context_slots')) {
                        console.log('ðŸ†• CONTEXT SLOTS: Added extra_context_slots column');
                    }
                    if (columnQuery.includes('total_context_slots')) {
                        console.log('ðŸ†• CONTEXT SLOTS: Added total_context_slots column');
                    }
                    // Log admin column addition
                    if (columnQuery.includes('is_admin')) {
                        console.log('ðŸ”’ ADMIN: Added is_admin column');
                    }
                    // Log Chargebee column additions
                    if (columnQuery.includes('chargebee_subscription_id')) {
                        console.log('âœ… CHARGEBEE FIX: Added chargebee_subscription_id column');
                    }
                    if (columnQuery.includes('chargebee_customer_id')) {
                        console.log('âœ… CHARGEBEE FIX: Added chargebee_customer_id column');
                    }
                    // Log cancellation column additions
                    if (columnQuery.includes('cancellation_scheduled_at')) {
                        console.log('âœ… CANCELLATION FIX: Added cancellation_scheduled_at column');
                    }
                    if (columnQuery.includes('cancellation_effective_date')) {
                        console.log('âœ… CANCELLATION FIX: Added cancellation_effective_date column');
                    }
                    if (columnQuery.includes('previous_plan_code')) {
                        console.log('âœ… CANCELLATION FIX: Added previous_plan_code column');
                    }
                } catch (err) {
                    console.log(`Column might already exist: ${err.message}`);
                }
            }

            // FIXED: Update existing VARCHAR(500) columns to TEXT
            try {
                await pool.query(`ALTER TABLE users ALTER COLUMN profile_picture TYPE TEXT;`);
                console.log('Updated users.profile_picture to TEXT');
            } catch (err) {
                console.log(`Profile picture column update: ${err.message}`);
            }

            try {
                await pool.query(`ALTER TABLE user_profiles ALTER COLUMN profile_image_url TYPE TEXT;`);
                console.log('Updated user_profiles.profile_image_url to TEXT');
            } catch (err) {
                console.log(`Profile image URL column update: ${err.message}`);
            }

            try {
                await pool.query(`ALTER TABLE message_logs ALTER COLUMN target_url TYPE TEXT;`);
                console.log('Updated message_logs.target_url to TEXT');
            } catch (err) {
                console.log(`Target URL column update: ${err.message}`);
            }
            
            // Make password_hash nullable
            try {
                await pool.query(`ALTER TABLE users ALTER COLUMN password_hash DROP NOT NULL;`);
            } catch (err) {
                console.log(`Password hash column already nullable: ${err.message}`);
            }

            // Add enhanced fields to user_profiles only
            const enhancedProfileColumns = [
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS initial_scraping_done BOOLEAN DEFAULT false',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS current_job_title TEXT',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS total_likes INTEGER DEFAULT 0',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS total_comments INTEGER DEFAULT 0',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS total_shares INTEGER DEFAULT 0',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS average_likes DECIMAL(10,2) DEFAULT 0',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS awards JSONB DEFAULT \'[]\'::JSONB',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS engagement_data JSONB DEFAULT \'{}\'::JSONB',
                'ALTER TABLE user_profiles ADD COLUMN IF NOT EXISTS mutual_connections_count INTEGER DEFAULT 0'
            ];

            for (const columnQuery of enhancedProfileColumns) {
                try {
                    await pool.query(columnQuery);
                } catch (err) {
                    console.log(`Column might already exist: ${err.message}`);
                }
            }

            // âœ… NEW: Add GPT-5 message logging columns to existing message_logs table + MESSAGE_TYPE FIX + CAMPAIGN TRACKING
            const gpt5MessageColumns = [
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS target_profile_url TEXT',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS context_text TEXT',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS target_first_name VARCHAR(255)',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS target_title VARCHAR(500)',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS target_company VARCHAR(500)',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS model_name VARCHAR(100)',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS prompt_version VARCHAR(255)',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS input_tokens INTEGER',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS output_tokens INTEGER',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS total_tokens INTEGER',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS latency_ms INTEGER',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS data_json JSONB',
                
                // âœ… NEW: Campaign tracking fields for Messages page
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS sent_status VARCHAR(20) DEFAULT \'pending\'',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS reply_status VARCHAR(20) DEFAULT \'pending\'',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS comments TEXT',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS sent_date TIMESTAMP',
                'ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS reply_date TIMESTAMP'
            ];

            console.log('-- âœ… NEW: GPT-5 Message Logging columns + CAMPAIGN TRACKING');
            
            for (const columnQuery of gpt5MessageColumns) {
                try {
                    await pool.query(columnQuery);
                    // Log successful addition of campaign tracking columns
                    if (columnQuery.includes('sent_status')) {
                        console.log('âœ… MESSAGES FIX: Added sent_status column for campaign tracking');
                    }
                    if (columnQuery.includes('reply_status')) {
                        console.log('âœ… MESSAGES FIX: Added reply_status column for campaign tracking');
                    }
                    if (columnQuery.includes('comments')) {
                        console.log('âœ… MESSAGES FIX: Added comments column for campaign tracking');
                    }
                } catch (err) {
                    console.log(`GPT-5 column might already exist: ${err.message}`);
                }
            }

            // âœ… MESSAGE TYPE FIX: Update message_type column to use proper constraint
            try {
                // First add the column if it doesn't exist
                await pool.query(`ALTER TABLE message_logs ADD COLUMN IF NOT EXISTS message_type VARCHAR(50) DEFAULT 'linkedin_message';`);
                console.log('âœ… MESSAGE TYPE FIX: Added message_type column');
                
                // Then add the constraint
                await pool.query(`
                    ALTER TABLE message_logs DROP CONSTRAINT IF EXISTS message_logs_message_type_check;
                    ALTER TABLE message_logs ADD CONSTRAINT message_logs_message_type_check 
                    CHECK (message_type IN ('linkedin_message', 'connection_request', 'cold_email'));
